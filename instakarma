#!/usr/bin/env python3

import argparse
import logging

import os
import sqlite3

from argparse import ArgumentParser
from logging import Logger
from sqlite3 import Connection, Cursor
from typing import Final

# --- CONSTANTS ---

DB_FILE: Final[str] = 'instakarma.db'
DB_DDL_FILE: Final[str] = 'instakarma_ddl.sql'


# --- HELPER METHODS --

def add_entity(conn: Connection, name: str, logger: Logger) -> None:
    try:
        conn.execute("INSERT OR IGNORE INTO entities (entity_name) VALUES (?)", (name,))
    except sqlite3.Error as e:
        logger.error(f"SQLite error: {e}. Rolling back.")
        conn.rollback()
        raise


def get_karma(conn: Connection, name: str, logger: Logger) -> int:
    try:
        cursor: Cursor = conn.execute("SELECT karma FROM entities WHERE entity_name = ?", (name,))
        result = cursor.fetchone()
        return result[0] if result else 0
    except sqlite3.Error as e:
        logger.error(f"SQLite error: {e}. Rolling back.")
        raise


def grant_karma(conn: Connection, granter: str, recipient: str, delta: int, logger: Logger) -> None:
    add_entity(conn, granter, logger)
    add_entity(conn, recipient, logger)

    if entity_disabled(conn, recipient):
        logger.info(f"Not granting karma to disabled entity '{recipient}'")
        # TODO: send message to Slack saying recipient is not participating in Instakarma
        return

    try:
        # insert into the `actions` table using subqueries to look up `entity_id` for granter and recipient
        conn.execute("""INSERT INTO actions (granter_id, recipient_id, delta)
                            SELECT
                                (SELECT entity_id FROM entities WHERE entity_name = ?),
                                (SELECT entity_id FROM entities WHERE entity_name = ?),
                                ?""",
                     (granter, recipient, delta))

        conn.execute("UPDATE entities SET karma = karma + ? WHERE entity_name = ?",
                     (delta, recipient))
        conn.commit()

    except sqlite3.Error as e:
        logger.error(f"SQLite error occurred: {e}. Rolling back.")
        conn.rollback()
        raise


def entity_disabled(conn: Connection, entity_name: str) -> bool:
    try:
        cursor: Cursor = conn.execute("SELECT disabled FROM entities WHERE entity_name = ?",
                                      (entity_name,))
        return cursor.fetchone()[0]
    except sqlite3.Error as e:
        print(f"A SQLite error occurred: {e}")
        raise


# --- main operations ---

def disable_entity() -> None:
    pass


def init_db(logger: Logger) -> None:
    if os.path.exists(DB_FILE):
        logger.info(f"Database file '{DB_FILE}' already exists. No changes made.")
    else:
        with sqlite3.connect(DB_FILE) as conn:
            with open('instakarma_ddl.sql') as ddl_file:
                ddl: str = ddl_file.read()
            conn.executescript(ddl)


def list_alphabetical(logger: Logger) -> None:
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor: Cursor = conn.execute("SELECT karma, entity_name "
                                          "FROM entities "
                                          "WHERE disabled = FALSE "
                                          "ORDER BY entity_name;")
            results = cursor.fetchall()
            for entity_name, karma in results:
                print(f"{entity_name} {karma}")
    except sqlite3.Error as e:
        logger.error(f"SQLite error occurred: {e}.")
        raise


def list_ranked(logger: Logger) -> None:
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor: Cursor = conn.execute("SELECT karma, entity_name "
                                          "FROM entities "
                                          "WHERE disabled = FALSE "
                                          "ORDER BY karma DESC;")
            results = cursor.fetchall()
            for karma, entity_name in results:
                print(f"{karma}\t{entity_name}")
    except sqlite3.Error as e:
        logger.error(f"SQLite error occurred: {e}.")
        raise


def monitor_slack() -> None:
    pass


def test(logger: Logger) -> None:
    # try:
    #     os.remove(DB_FILE)
    # except FileNotFoundError:
    #     pass
    init_db(logger)

    with sqlite3.connect(DB_FILE) as conn:
        try:
            grant_karma(conn, "@alice", "@bob", 1, logger)
            grant_karma(conn, "@bob", "@charlie", 1, logger)
            grant_karma(conn, "@charlie", "@alice", -1, logger)
            grant_karma(conn, "@alice", "@bob", 1, logger)
            grant_karma(conn, "@charlie", "@bob", 1, logger)

            conn.commit()

            print("Karma for @alice:", get_karma(conn, "@alice", logger))
            print("Karma for @bob:", get_karma(conn, "@bob", logger))
            print("Karma for @charlie:", get_karma(conn, "@charlie", logger))

        except sqlite3.Error as e:
            logger.error(f"SQLite error occurred: {e}. Rolling back.")
            conn.rollback()


def view_all_grants(logger: Logger):
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor: Cursor = conn.execute("SELECT r.entity_name AS recipient_name, "
                                                 "g.entity_name AS granter_name, "
                                                 "a.delta,"
                                                 "a.timestamp "
                                          "FROM actions a "
                                          "JOIN entities r on a.recipient_id = r.entity_id "
                                          "JOIN entities g on a.granter_id = g.entity_id "
                                          "ORDER BY a.timestamp;")
            results = cursor.fetchall()
            for recipient_name, granter_name, delta, timestamp in results:
                print(f"{timestamp},{granter_name},{delta},{recipient_name}")
    except sqlite3.Error as e:
        logger.error(f"SQLite error occurred: {e}.")
        raise


def main() -> None:
    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(levelname)s - %(message)s',
                        datefmt='%m/%d/%Y %I:%M:%S %p',
                        filename='instakarma.log')

    logger = logging.getLogger(__name__)

    parser: ArgumentParser = argparse.ArgumentParser(
        description='Instakarma: a Slack app karmabot',
        epilog='author: Chris Cowell (christopher.cowell@instabase.com')

    group = parser.add_mutually_exclusive_group()

    group.add_argument('-d', '--disable-entity', metavar='<ENTITY-TO-DISABLE>',
                       help='Disable an entity, like `@Bob` or `Python`')
    group.add_argument('-i', '--init-db', action='store_true', help='Non-destructively initialize the DB')
    group.add_argument('-la', '--list-alphabetical', action='store_true', help='List users in alphabetical order')
    group.add_argument('-lr', '--list-ranked', action='store_true', help='List users in karma order')
    group.add_argument('-m', '--monitor-slack', action='store_true', help='monitor Slack (this is normal mode)')
    group.add_argument('-v', '--view-all-grants', action='store_true', help='View history of all karma grants')
    group.add_argument('--test', action='store_true', help='For debugging only -- remove this in prod')

    args = parser.parse_args()

    if args.disable_entity:
        disable_entity()
    elif args.init_db:
        init_db(logger)
    elif args.list_alphabetical:
        list_alphabetical(logger)
    elif args.list_ranked:
        list_ranked(logger)
    elif args.monitor_slack:
        monitor_slack()
    elif args.test:
        test(logger)
    elif args.view_all_grants:
        view_all_grants(logger)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
