#!/usr/bin/env python3

from exceptions import *
from logs import *

from enum import Enum, auto
import os
import re
import sqlite3
from sqlite3 import Connection, Cursor

from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler


# ---
# Enums
# ---

class Action(Enum):
    """Every attempt to grant karma must have an Action associated with it, so we know
    if the grant increases or decreases the recipient's karma."""
    INCREMENT = auto()
    DECREMENT = auto()


class Status(Enum):
    """Slack users can disable themselves if they don't want to participate in instakarma."""
    ENABLED: str = 'enabled'
    DISABLED: str = 'disabled'


# ---
# DB utilities
# ---

def get_db_connection() -> Connection:
    try:
        with sqlite3.connect(DB_FILE) as conn:
            return conn
    except sqlite3.Error as e:
        log_error_and_quit(f"Couldn't connect to database file '{DB_FILE}': {e}")


def init_db() -> None:
    if os.path.exists(DB_FILE):
        logger.info(f"Database file '{DB_FILE}' already exists. No changes made.")
        return

    with get_db_connection() as conn:
        with open(DB_DDL_FILE) as ddl_file:
            ddl: str = ddl_file.read()
        try:
            conn.executescript(ddl)
            conn.commit()
            logger.info(f"Creating new DB at '{DB_FILE}' using DDL '{DB_DDL_FILE}'")
        except sqlite3.Error as e:
            log_error_and_quit(f"Couldn't create DB: {e}")


def execute_query(conn: Connection, query: str, parms: tuple) -> Cursor:
    try:
        cursor: Cursor = conn.execute(query, parms)
        conn.commit()
        return cursor
    except sqlite3.Error as e:
        logger.error(f"Rolling back. puery: {query} | parms: '{parms}' | error: {e}")
        conn.rollback()
        raise e


# ---
# Helpers
# ---

def log_error_and_quit(msg: str) -> None:
    logger.critical(msg)
    print(f"FATAL ERROR. {msg}")
    os._exit(1)  # sys.exit() is handled by the Slack app, so we have to pull out the big guns


def is_entity_disabled(conn: Connection, name: str) -> bool:
    is_disabled: bool = False
    logger.debug(f"Asking DB if row with 'entity.name' of '{name}' is disabled")
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       SELECT disabled
                                       FROM entities
                                       WHERE name = ?
                                       """,
                                       (name,))
        result = cursor.fetchone()
        if result and result[0]:
            is_disabled = True

        if is_disabled:
            logger.debug(f"DB says row with 'entity.name' of '{name}' is disabled")
            return True
        else:
            logger.debug(f"DB says row with 'entity.name' of '{name}' is not disabled")
            return False

    except sqlite3.Error as e:
        logger.error(f"Couldn't check if '{name}' is disabled: {e}")
        raise e


def get_name_from_user_id(conn: Connection, user_id: str) -> str:
    # If row exists in DB with that `user_id` and `name`, RETURN `name`.
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       SELECT name
                                       FROM entities
                                       WHERE user_id = ?;
                                       """,
                                       (user_id,))
    except sqlite3.Error as e:
        logger.error(f"Couldn't look up 'entity.name' for 'entity.user_id' of '{user_id}': {e}")
        raise e

    first_row_of_results = cursor.fetchone()
    if first_row_of_results:
        return first_row_of_results[0]

    # Else if row exists for that `user_id`, look up `name` in the API and update the row with `name`. RETURN `name`.
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       SELECT * 
                                       FROM entities
                                       WHERE user_id = ?;
                                       """,
                                       (user_id,))
    except sqlite3.Error as e:
        logger.error(f"Couldn't look up whether there's a row in 'entities' with 'entity.user_id' == {user_id}': {e}")
        raise e

    first_row_of_results = cursor.fetchone()
    if first_row_of_results:
        name: str = get_name_from_slack(user_id)
        try:
            cursor: Cursor = execute_query(conn,
                                           """
                                           UPDATE entities
                                            SET name = ?
                                            WHERE user_id = ?;
                                           """,
                                           (name, user_id))
        except sqlite3.Error as e:
            logger.error(f"Couldn't update 'entities' table to set 'name' for 'user_id' of '{user_id}': {e}")
            raise e
        return name

    # Else look up the `name` in the API and insert a row with `name` and `user_id`. RETURN `name`.
    name: str = get_name_from_slack(user_id)
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       INSERT INTO entities (name, user_id) 
                                       VALUES (?, ?);
                                       """,
                                       (name, user_id))
    except sqlite3.Error as e:
        logger.error(f"Couldn't insert row into 'entities' table with name '{name}' and user_id '{user_id}': {e}")
        raise e
    return name


def get_name_from_slack(user_id: str) -> str:
    """Use Slack API to convert a user ID (e.g., 'U07R69E3YKB') into a user name (e.g., '@elvis')."""
    logger.debug(f"Asking Slack API for user info for user with user_id '{user_id}'")
    user_info = app.client.users_info(user=user_id)
    name = user_info['user']['name']
    logger.debug(f"Slack API returned name '{name}' for user with user_id '{user_id}'")
    name = '@' + name
    return name


def detect_valid_user_recipients(conn: Connection, msg_text: str) -> list[tuple[str, str]]:
    """Capture "foo" and "++" from "<@foo>++" and "<@foo> ++".

    This covers cases where the recipient is a user registered in Slack
    """
    recipient_is_valid_user_regex: str = r'<@(.*?)>\s?((\+\+)|(--))'
    regex_matches = re.findall(recipient_is_valid_user_regex, msg_text)
    recognized_user_recipients: list[tuple[str, str]] = []
    for match in regex_matches:
        recipient_user_id: str = match[0]
        action: str = match[1]
        recognized_user_recipients.append((recipient_user_id, action))
    return recognized_user_recipients


def detect_invalid_user_recipients(msg_text: str) -> list[tuple[str, str]]:
    """Capture "foo" from "@foo++" and "@foo ++" where there's no "<" before the "@".

    This covers cases of trying to grant karma to a user not registered in Slack.
    """
    recipient_is_invalid_user_regex: str = r'(?<!<)(@\w+)\s?(\+\+|--)'
    regex_matches = re.findall(recipient_is_invalid_user_regex, msg_text)
    invalid_user_recipients: list[tuple[str, str]] = []
    for match in regex_matches:
        recipient_name: str = match[0]
        action: str = match[1]
        invalid_user_recipients.append((recipient_name, action))
    return invalid_user_recipients


def detect_object_recipients(msg_text: str) -> list[tuple[str, str]]:
    """Capture "foo" and "++" from "foo++" and "foo ++ only when there's no @ before "foo".

    This covers cases where the recipient is a non-person, like "banyan" or "the-internet"
    """
    recipient_is_object_regex: str = r'\b(?<!@)([\w-]+)\s?((\+\+)|(--))'
    regex_matches = re.findall(recipient_is_object_regex, msg_text)
    object_recipients: list[tuple[str, str]] = []
    for match in regex_matches:
        recipient_name: str = match[0].lower()
        action: str = match[1]
        object_recipients.append((recipient_name, action))
    return object_recipients


# ---
# Karma logic
# ---

def get_karma(conn: Connection, name: str) -> int:
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       SELECT karma
                                       FROM entities
                                       WHERE name = ? AND disabled = FALSE
                                       """,
                                       (name,))
        result = cursor.fetchone()
        if result:
            return result[0]
        else:
            logger.info(f"entity with name '{name}' is disabled or doesn't exist in 'entities' table")
            raise ValueError
    except sqlite3.Error as e:
        logger.error(f"Couldn't get karma for entity with name '{name}'")
        raise e


def get_status(conn: Connection, name: str) -> Status:
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       SELECT disabled
                                       FROM entities
                                       WHERE name = ?
                                       """,
                                       (name,))
        result = cursor.fetchone()
        if result:
            return Status.DISABLED if result[0] else Status.ENABLED
        logger.info(f"Entity with name '{name}' doesn't exist in 'entities' table")
        raise ValueError
    except sqlite3.Error as e:
        logger.error(f"Couldn't get karma for '{name}'")
        raise e


def get_top_granters(conn: Connection, recipient_name: str) -> list[tuple[str, int]]:
    try:
        cursor: Cursor = execute_query(conn,
                                       f"""
                                       SELECT e_granter.name as top_granter_name,
                                              COUNT(*) as times_granted
                                       FROM grants g
                                       JOIN entities e_granter ON g.granter_id = e_granter.entity_id
                                       JOIN entities e_recipient ON g.recipient_id = e_recipient.entity_id
                                       WHERE e_recipient.name = ?
                                       GROUP BY g.granter_id
                                       ORDER BY times_granted DESC
                                       LIMIT {NUM_TOP_GRANTERS};
                                       """,
                                       (recipient_name,))
        biggest_granters: list[tuple[str, int]] = []
        for row in cursor.fetchall():
            granter_name: str = row[0]
            times_granted: int = int(row[1])
            biggest_granters.append((granter_name, int(times_granted)))
        return biggest_granters
    except sqlite3.Error as e:
        logger.error(f"Couldn't get biggest granters to user with name '{recipient_name}': {e}")
        raise e


def get_top_recipients(conn: Connection, granter_name: str) -> list[tuple[str, int]]:
    try:
        cursor: Cursor = execute_query(conn,
                                       f"""
                                       SELECT e_recipient.name as top_recpient_name,
                                              COUNT(*) as times_received
                                       FROM grants g
                                       JOIN entities e_granter ON g.granter_id = e_granter.entity_id
                                       JOIN entities e_recipient ON g.recipient_id = e_recipient.entity_id
                                       WHERE e_granter.name = ?
                                       GROUP BY g.recipient_id
                                       ORDER BY times_received DESC
                                       LIMIT {NUM_TOP_RECIPIENTS};
                                       """,
                                       (granter_name,))
        biggest_recipients: list[tuple[str, int]] = []
        for row in cursor.fetchall():
            recipient_name: str = row[0]
            times_granted: int = int(row[1])
            biggest_recipients.append((recipient_name, int(times_granted)))
        return biggest_recipients
    except sqlite3.Error as e:
        logger.error(f"Couldn't get biggest recipients from user with name '{granter_name}': {e}")
        raise e


def grant_karma(conn: Connection, granter_name: str, recipient_name: str, amount: int) -> None:
    if is_entity_disabled(conn, recipient_name):
        raise DisabledEntityError

    try:
        # make an entry in the 'grants' table using subqueries to look up 'entity_id' for granter and recipient
        execute_query(conn,
                      """
                      INSERT INTO grants (granter_id, recipient_id, amount)
                      SELECT
                          (SELECT entity_id FROM entities WHERE name = ?),
                          (SELECT entity_id FROM entities WHERE name = ?),
                          ?
                      """,
                      (granter_name, recipient_name, amount))
        # make an entry in the 'entities' table, which tracks total karma for each user
        execute_query(conn,
                      """
                      UPDATE entities
                      SET karma = karma + ?
                      WHERE name = ?
                      """,
                      (amount, recipient_name))
        conn.commit()
        logger.info(f"'{granter_name}' granted '{amount}' karma to '{recipient_name}'")

    except sqlite3.Error as e:
        logger.error(f"Couldn't grant '{amount}' karma from '{granter_name}' to '{recipient_name}': {e}")
        raise e


def add_object_entity(conn: Connection, name: str) -> None:
    """Add an object entity to the table if it doesn't already exist."""
    try:
        execute_query(conn,
                      """
                      INSERT OR IGNORE INTO entities (name)
                      VALUES (?)
                      """,
                      (name,))
    except sqlite3.Error as e:
        logger.error(f"Couldn't add object entity '{name}': {e}")
        raise e


def change_user_status(conn: Connection, name: str, status: Status) -> None:
    try:
        execute_query(conn,
                      f"""
                            UPDATE entities
                            SET disabled = {'TRUE' if status == Status.DISABLED else 'FALSE'}
                            WHERE name = ?
                            """,
                      (name,))
        logger.info(f"Entity '{name}' now has status '{status.value}'")
    except sqlite3.Error as e:
        logger.error(f"Couldn't set user '{name}' status to '{status.value}': {e}")


def get_action_amount_and_verb(recipient: tuple[str, str]) -> (Action, int, str):
    if recipient[1] == '++':
        logger.debug("setting action to INCREMENT, amount to 1, verb to 'leveled up'")
        return Action.INCREMENT, 1, 'leveled up'
    if recipient[1] == '--':
        logger.debug("setting action to DECREMENT, amount to -1, verb to 'took a hit'")
        return Action.DECREMENT, -1, 'took a hit'
    log_error_and_quit(f"Unrecognized action is neither '++' nor '--': '{recipient[1]}'")


# ---
# Main logic
# ---

app: App = App(token=os.environ.get("SLACK_BOT_TOKEN"))


# Listen for "++" or "--" in any message in any channel the bot subscribes to.
@app.message(r'(\+\+)|(--)')
def handle_karma_grants(message: dict, say) -> None:
    with get_db_connection() as conn:
        granter_user_id: str = message['user']
        message_text: str = message['text']

        valid_user_recipients: list[tuple[str, str]] = detect_valid_user_recipients(conn, message_text)
        logger.debug("recognized user recipients: " + str(valid_user_recipients))

        invalid_user_recipients: list[tuple[str, str]] = detect_invalid_user_recipients(message_text)
        logger.debug("unrecognized user recipients: " + str(invalid_user_recipients))

        object_recipients: list[tuple[str, str]] = detect_object_recipients(message_text)
        logger.debug("object recipients: " + str(object_recipients))

        action: Action
        amount: int
        verb: str

        for recipient in valid_user_recipients:
            recipient_user_id: str = recipient[0]
            action, amount, verb = get_action_amount_and_verb(recipient)

            granter_name: str = get_name_from_user_id(conn, granter_user_id)
            recipient_name: str = get_name_from_user_id(conn, recipient_user_id)

            if action == Action.DECREMENT:
                logger.info(f"'{granter_name}' tried to grant {amount} karma to a user")
                say('Sorry, you can only remove karma from things (like "python"), not people (like @elvis).')
                continue

            if recipient_name == granter_name:
                logger.info(f"'{granter_name}' tried to self-grant {amount} karma")
                say(f"Sorry, you can't self-grant karma.")
                continue

            try:
                grant_karma(conn, granter_name, recipient_name, amount)
                recipient_total_karma: int = get_karma(conn, recipient_name)
                say(f"<{recipient_name}> {verb}, now has {recipient_total_karma} karma")
            except DisabledEntityError as dee:
                logger.info(f"'{granter_name}' can't grant karma to disabled entity '{recipient_name}'")
                say(f"Sorry, {recipient_name} isn't participating in Instakarma.")

        for recipient in invalid_user_recipients:
            granter_name: str = get_name_from_user_id(conn, granter_user_id)
            recipient_name: str = recipient[0]
            action, amount, verb = get_action_amount_and_verb(recipient)
            logger.info(f"'{granter_name}' tried to grant '{amount}' karma "
                        f"to unrecognized user '{recipient_name}'")
            say(f"Sorry, I don't recognize the user {recipient_name}.")

        for recipient in object_recipients:
            granter_name: str = get_name_from_user_id(conn, granter_user_id)
            recipient_name: str = recipient[0]
            action, amount, verb = get_action_amount_and_verb(recipient)
            add_object_entity(conn, recipient_name)
            try:
                grant_karma(conn, granter_name, recipient_name, amount)
                recipient_total_karma: int = get_karma(conn, recipient_name)
                say(f"{recipient_name} {verb}, now has {recipient_total_karma} karma.")
            except DisabledEntityError as dee:
                logger.info(f"'{granter_name}' can't grant karma to disabled entity '{recipient_name}'")
                say(f"Sorry, {recipient_name} is not participating in Instakarma.")


@app.command('/instakarma')
def handle_instakarma_command(ack, command, say) -> None:
    ack()
    text = command['text'].lower()

    if text == 'help':
        say(
            text="How to use Instakarma",
            blocks=[
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": ("*instakarma usage*\n"
                                 "• `@robin++` - Give 1 karma to Slack user `@robin`\n"
                                 "• `python++` - Give 1 karma to non-person `python`\n"
                                 "• `python--` - Remove 1 karma from non-person `python`\n"
                                 "• `/instakarma stats` - See your karma and top granters and receivers\n"
                                 "• `/instakarma disable-me` - Decline to participate in instakarma\n"
                                 "• `/instakarma enable-me` - Participate in instakarma\n"
                                 "\n"
                                 "Optionally add a space between `recipient` and `++` or `--`")
                    }
                }
            ],
            ephemeral=True  # response visible only to the user who typed the command
        )

    if text == 'disable-me':
        name: str = '@' + command['user_name']
        with get_db_connection() as conn:
            change_user_status(conn, name, Status.DISABLED)
        say(f"{name} is disabled in instakarma.")

    if text == 'enable-me':
        name: str = '@' + command['user_name']
        with get_db_connection() as conn:
            change_user_status(conn, name, Status.ENABLED)
        say(f"{name} is enabled in instakarma.")

    if text == 'my-stats':
        name: str = '@' + command['user_name']
        with get_db_connection() as conn:
            status: Status = get_status(conn, name)
            if status == status.DISABLED:
                say("You're disabled in Instakarma -- re-enable with `/instakarma enable-me`")
                return
            total_karma: int = get_karma(conn, name)

        your_karma_text: str = f">You have *{get_karma(conn, name)}* karma\n"

        top_recipients_text: str = ''
        top_recipients: list[tuple[str, int]] = get_top_recipients(conn, name)
        if top_recipients:
            top_recipients_text = ">*Your top karma recipients*\n"
            for recipient in top_recipients:
                top_recipients_text += f">• {str(recipient[1])} to {recipient[0]}\n"

        top_granters_text: str = ''
        top_granters: list[tuple[str, int]] = get_top_granters(conn, name)
        if top_granters:
            top_granters_text = ">*Your top karma granters*\n"
            for granter in top_granters:
                top_granters_text += f">• {str(granter[1])} from {granter[0]}\n"

        say(
            text=f"instakarma stats for {name}",
            blocks=[
                {"type": "section",
                 "text": {"type": "mrkdwn",
                          "text": (f"*instakarma stats for {name}*\n"
                                   "\n"
                                   f"{your_karma_text}"
                                   ">\n"
                                   f"{top_recipients_text}"
                                   ">\n"
                                   f"{top_granters_text}")
                          }
                 }
            ],
            ephemeral=True  # response visible only to the user who typed the command
        )


if __name__ == "__main__":
    logger: Logger = init_logger()  # global var, instead of passing it all around
    init_db()  # non-destructively create a DB
    SocketModeHandler(app=app, app_token=os.environ["SLACK_APP_TOKEN"]).start()

# TODO: add logger.info before all SQL queries. Maybe in execute.query(), but maybe elsewhere too.