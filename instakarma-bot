#!/usr/bin/env python3

from exceptions import *
from log import *

import os
import re
import sqlite3
from sqlite3 import Connection, Cursor

from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler


# ---
# DB utilities
# ---

def get_db_connection() -> Connection:
    try:
        with sqlite3.connect(DB_FILE) as conn:
            return conn
    except sqlite3.Error as e:
        log_error_and_quit(f"Couldn't connect to database file '{DB_FILE}': {e}")


def init_db() -> None:
    if os.path.exists(DB_FILE):
        logger.info(f"Database file '{DB_FILE}' already exists. No changes made.")
        return

    with get_db_connection() as conn:
        with open(DB_DDL_FILE) as ddl_file:
            ddl: str = ddl_file.read()
        try:
            conn.executescript(ddl)
            conn.commit()
            logger.info(f"Creating new DB at '{DB_FILE}' using DDL '{DB_DDL_FILE}'")
        except sqlite3.Error as e:
            log_error_and_quit(f"Error when creating DB: {e}")


def execute_query(conn: Connection, query: str, parms: tuple) -> Cursor:
    try:
        cursor: Cursor = conn.execute(query, parms)
        conn.commit()
        return cursor
    except sqlite3.Error as e:
        logger.error(f"Rolling back because of error: {e} --- Query: {query} --- Parms: {parms}")
        conn.rollback()
        raise e


# ---
# Helpers
# ---


def is_entity_disabled(conn: Connection, entity: str) -> bool:
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       SELECT disabled
                                       FROM entities
                                       WHERE name = ?
                                       """,
                                       (entity,))
        return cursor.fetchone()[0]
    except sqlite3.Error as e:
        logger.error(f"Couldn't check if '{entity}' is disabled: {e}")
        raise e


def convert_user_id_to_user_name(conn: Connection, user_id: str) -> str:
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       SELECT name
                                       FROM entities
                                       WHERE user_id = ?;
                                       """,
                                       (user_id,))
    except sqlite3.Error as e:
        logger.error(f"Couldn't look up 'entity.name' for 'entity.user_id' of '{user_id}': {e}")
        raise e

    first_row_of_results = cursor.fetchone()
    if first_row_of_results:
        return first_row_of_results[0]
    logger.info(f"No name in DB for entity with user_id: '{user_id}'. Fetching via API and storing in DB.")
    user_name: str = get_user_name_from_slack(user_id)
    try:
        execute_query(conn,
                      """
                      UPDATE entities
                      SET name = ?
                      WHERE user_id = ?;
                      """,
                      (user_name, user_id))
    except sqlite3.Error as e:
        logger.error(f"Couldn't update 'entities' table to set 'name' for 'user_id' of '{user_id}': {e}")
        raise e
    return user_name


def get_user_name_from_slack(user_id: str) -> str:
    """Use Slack API to convert a user ID (e.g., 'U07R69E3YKB') into a user name (e.g., '@elvis')."""
    user_info = app.client.users_info(user=user_id)
    user_name = user_info['user']['name']
    user_name = '@' + user_name
    return user_name


def detect_recognized_user_recipients(conn: Connection, msg_text: str) -> list[tuple[str, str]]:
    # Capture "foo" and "++" from "<@foo>++" and "<@foo> ++".
    # This covers cases where the recipient is a user who is registered in Slack
    recipient_is_recognized_user_regex: str = r'<@(.*?)>\s?((\+\+)|(--))'
    regex_matches = re.findall(recipient_is_recognized_user_regex, msg_text)
    recognized_user_recipients: list[tuple[str, str]] = []
    for match in regex_matches:
        recipient_user_id: str = match[0]
        action: str = match[1]
        recipient_user_name: str = convert_user_id_to_user_name(conn, recipient_user_id)
        recognized_user_recipients.append((recipient_user_name, action))
    return recognized_user_recipients


def detect_unrecognized_user_recipients(msg_text: str) -> list[tuple[str, str]]:
    # Capture "foo" from "@foo++" and "@foo ++" where there's no "<" before the "@"
    # This covers cases of trying to grant karma to a user not registered in Slack.
    recipient_is_unrecognized_user_regex: str = r'(?<!<)@(\w+)\s?(\+\+|--)'
    regex_matches = re.findall(recipient_is_unrecognized_user_regex, msg_text)
    unrecognized_user_recipients: list[tuple[str, str]] = []
    for match in regex_matches:
        recipient_name: str = match[0]
        action: str = match[1]
        unrecognized_user_recipients.append((recipient_name, action))
    return unrecognized_user_recipients


def detect_object_recipients(msg_text: str) -> list[tuple[str, str]]:
    # Capture "foo" and "++" from "foo++" and "foo ++ only when there's no @ before "foo".
    # This covers cases where the recipient is a non-person, like "banyan" or "the-internet"
    recipient_is_object_regex: str = r'\b(?<!@)([\w-]+)\s?((\+\+)|(--))'
    regex_matches = re.findall(recipient_is_object_regex, msg_text)
    object_recipients: list[tuple[str, str]] = []
    for match in regex_matches:
        recipient_name: str = match[0].lower()
        action: str = match[1]
        object_recipients.append((recipient_name, action))
    return object_recipients


# ---
# Karma logic
# ---

def get_karma(conn: Connection, entity: str) -> int:
    try:
        cursor: Cursor = execute_query(conn,
                                       """
                                       SELECT karma
                                       FROM entities
                                       WHERE name = ? AND disabled = FALSE
                                       """,
                                       (entity,))
        result = cursor.fetchone()
        if result:
            return result[0]
        else:
            logger.info(f"Entity '{entity}' is disabled or doesn't exist in 'entities' table")
            raise ValueError

    except sqlite3.Error as e:
        logger.error(f"Couldn't get karma for '{entity}'")
        raise e


def grant_karma(conn: Connection, granter_user_name: str, recipient_user_name: str, amount: int) -> None:
    add_entity(conn, name=recipient_user_name)
    # TODO: WHAT HAPPENS IF YOU MAKE AN ENTRY IN 'ENTITIES' WITH JUST USERNAME, AND THEN THAT USER TRIES TO GRANT KARMA?
    if is_entity_disabled(conn, recipient_user_name):
        logger.info(f"Can't grant karma to disabled entity '{recipient_user_name}'")
        raise DisabledEntityError

    try:
        # make an entry in the 'grants' table using subqueries to look up 'entity_id' for granter and recipient
        execute_query(conn,
                      """
                      INSERT INTO grants (granter_id, recipient_id, amount)
                      SELECT
                          (SELECT entity_id FROM entities WHERE name = ?),
                          (SELECT entity_id FROM entities WHERE name = ?),
                          ?
                      """,
                      (granter_user_name, recipient_user_name, amount))
        # make an entry in the 'entities' table, which tracks total karma for each user
        execute_query(conn,
                      """
                      UPDATE entities
                      SET karma = karma + ?
                      WHERE name = ?
                      """,
                      (amount, recipient_user_name))
        conn.commit()
        logger.info(f"'{granter_user_name}' granted '{amount}' karma to '{recipient_user_name}'")

    except sqlite3.Error as e:
        logger.error(f"Error when granting '{amount}' karma "
                     f"from '{granter_user_name}' to '{recipient_user_name}': {e}")
        raise e


def add_entity(conn: Connection, user_id=None, name=None) -> None:
    """
    Add an entity to the table if it doesn't already exist.

    You must pass `user_id` or `name` or both. If the user already exists in the DB, this is a no-op.
    """
    if not (user_id or name):
        log_error_and_quit("Fatal: called `add_entry()` without passing either `user_id` or `name`")
    try:
        execute_query(conn,
                      """
                      INSERT OR IGNORE INTO entities (name, user_id)
                      VALUES (?, ?)
                      """,
                      (name, user_id))
    except sqlite3.Error as e:
        logger.error(f"Couldn't add entity '{name}': {e}")
        raise e


# ---
# Main logic
# ---

app: App = App(token=os.environ.get("SLACK_BOT_TOKEN"))

# Listen for "++" or "--" in any message in any channel the bot subscribes to.
@app.message(r'(\+\+)|(--)')
def grant_handler(message: dict, say) -> None:
    with get_db_connection() as conn:
        granter_user_id: str = message['user']
        granter_user_name: str = convert_user_id_to_user_name(conn, granter_user_id)
        add_entity(conn, user_id=granter_user_id, name=granter_user_name)
        message_text: str = message['text']

        recognized_user_recipients: list[tuple[str, str]] = detect_recognized_user_recipients(conn, message_text)
        print("recognized user recipients: " + str(recognized_user_recipients))

        object_recipients: list[tuple[str, str]] = detect_object_recipients(message_text)
        print("object recipients: " + str(object_recipients))

        unrecognized_user_recipients: list[tuple[str, str]] = detect_unrecognized_user_recipients(message_text)
        print("unrecognized user recipients: " + str(unrecognized_user_recipients))

        for recipient in recognized_user_recipients:
            recipient_user_name: str = recipient[0]
            action: str = recipient[1]
            amount = 1 if action == '++' else -1

            if recipient_user_name == granter_user_name:
                logger.info(f"'{granter_user_name}' tried to self-grant {amount} karma.")
                say(f"Sorry, you can't self-grant karma.")
                continue

            grant_karma(conn, granter_user_name, recipient_user_name, amount)
            recipient_total_karma: int = get_karma(conn, recipient_user_name)
            verb: str = 'leveled up' if action == '++' else 'took a hit'
            say(f"<{recipient_user_name}> {verb} (now has {recipient_total_karma} karma).")

        for recipient in object_recipients:
            recipient_user_name: str = recipient[0]
            action: str = recipient[1]
            if action == '++':
                amount: int = 1
                verb: str = "leveled up"
            else:
                amount: int = -1
                verb: str = "took a hit"
            grant_karma(conn, granter_user_name, recipient_user_name, amount)
            recipient_total_karma: int = get_karma(conn, recipient_user_name)
            say(f"{recipient_user_name} {verb}, now has {recipient_total_karma} karma.")

        for recipient in unrecognized_user_recipients:
            recipient_user_name: str = recipient[0]
            action: str = recipient[1]
            amount: int = 1 if action == '++' else -1
            logger.info(f"'{granter_user_name}' tried to grant '{amount}' karma "
                        f"to unrecognized user '{recipient_user_name}'")
            say(f"Sorry, I don't recognize the user name '{recipient_user_name}'.")


if __name__ == "__main__":
    logger: Logger = init_logger()  # global var, instead of passing it all around
    init_db()  # non-destructively create a DB
    SocketModeHandler(app=app, app_token=os.environ["SLACK_APP_TOKEN"]).start()
